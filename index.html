<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Ocean Cleanup - South China Sea</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #1a2980, #26d0ce);
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            image-rendering: pixelated;
            padding: 10px;
            touch-action: manipulation;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        #topUI {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            touch-action: none;
        }
        
        #gameCanvas {
            border: 3px solid #2c3e50;
            border-radius: 8px;
            background: linear-gradient(to bottom, #1e3c72, #2a5298);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
            width: 100%;
            height: auto;
            display: block;
            max-height: 70vh;
            object-fit: contain;
        }
        
        #uiOverlay {
            display: none; /* Hide the old overlay */
        }
        
        .uiPanel {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #3498db;
            font-size: 14px;
            flex: 1;
            min-width: 150px;
        }
        
        .uiPanel strong {
            color: #3498db;
        }
        
        .uiPanel > div {
            margin: 4px 0;
        }
        
        #controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #2ecc71;
            text-align: center;
            font-size: 12px;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        
        /* Mobile Controls */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }
        
        .mobileBtn {
            background: rgba(52, 152, 219, 0.8);
            border: 3px solid #3498db;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 24px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .mobileBtn:active {
            transform: scale(0.95);
            background: rgba(41, 128, 185, 0.9);
        }
        
        .mobileBtn.launch {
            width: 90px;
            height: 90px;
            font-size: 14px;
            background: rgba(46, 204, 113, 0.8);
            border-color: #2ecc71;
        }
        
        .mobileBtn.launch:active {
            background: rgba(39, 174, 96, 0.9);
        }
        
        #endScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 4px solid #e74c3c;
            text-align: center;
            display: none;
            max-width: 90vw;
            width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        #endScreen h2 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: clamp(20px, 5vw, 28px);
        }
        
        #endStats {
            margin: 15px 0;
            font-size: clamp(14px, 3.5vw, 18px);
        }
        
        .factBox {
            background: rgba(52, 152, 219, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
            font-size: 14px;
            line-height: 1.4;
            text-align: left;
        }
        
        #cycleImageContainer {
            background: rgba(231, 76, 60, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px solid #e74c3c;
        }
        
        #cycleImageContainer img {
            image-rendering: auto;
        }
        
        button {
            background: #2ecc71;
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 8px;
            border-radius: 6px;
            font-size: clamp(14px, 3vw, 16px);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            touch-action: manipulation;
        }
        
        button:hover, button:active {
            background: #27ae60;
            transform: scale(1.05);
        }
        
        #modeScreen, #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }
        
        #modeScreen h1, #startScreen h1 {
            font-size: clamp(32px, 8vw, 48px);
            color: #3498db;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        #modeScreen h2 {
            font-size: clamp(20px, 5vw, 28px);
            color: #3498db;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }
        
        #modeScreen p, #startScreen p {
            font-size: clamp(14px, 3.5vw, 18px);
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
            padding: 0 10px;
        }
        
        .key {
            display: inline-block;
            background: #34495e;
            padding: 4px 8px;
            margin: 0 3px;
            border-radius: 4px;
            border: 1px solid #7f8c8d;
            font-family: monospace;
            font-size: clamp(10px, 2.5vw, 14px);
        }
        
        .progressBar {
            width: 100%;
            max-width: 200px;
            height: 20px;
            background: #34495e;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px auto;
            border: 2px solid #2c3e50;
        }
        
        .progressFill {
            height: 100%;
            background: linear-gradient(to right, #e74c3c, #f39c12, #2ecc71);
            transition: width 0.3s;
        }
        
        .pixel-art {
            image-rendering: pixelated;
        }
        
        /* Responsive Design */
        @media (max-width: 900px) {
            #topUI {
                flex-direction: column;
                gap: 8px;
            }
            
            .uiPanel {
                min-width: 100%;
                padding: 10px 12px;
                font-size: 12px;
            }
            
            #controls {
                font-size: 11px;
                padding: 10px 12px;
            }
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                align-items: flex-start;
            }
            
            #gameContainer {
                gap: 8px;
            }
            
            #gameCanvas {
                max-height: 60vh;
            }
            
            #mobileControls {
                display: flex !important;
                bottom: 10px;
                gap: 10px;
            }
            
            #controls {
                display: none;
            }
            
            .uiPanel {
                font-size: 11px;
                padding: 8px 10px;
            }
            
            #endScreen {
                padding: 15px;
                max-width: 95vw;
            }
            
            .factBox {
                font-size: 12px;
                padding: 12px;
            }
            
            button {
                padding: 10px 20px;
                margin: 6px;
                font-size: 14px;
            }
            
            #cycleImageContainer {
                padding: 10px;
            }
            
            #cycleImageContainer div {
                font-size: 11px;
            }
        }
        
        /* Very small mobile devices */
        @media (max-width: 480px) {
            #topUI {
                gap: 5px;
            }
            
            .uiPanel {
                font-size: 10px;
                padding: 6px 8px;
            }
            
            .uiPanel > div {
                margin: 2px 0;
            }
            
            .mobileBtn {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            
            .mobileBtn.launch {
                width: 75px;
                height: 75px;
                font-size: 12px;
            }
            
            #mobileControls {
                gap: 8px;
                bottom: 5px;
            }
        }
        
        /* Landscape mobile orientation */
        @media (max-height: 600px) and (orientation: landscape) {
            #gameCanvas {
                max-height: 50vh;
            }
            
            #mobileControls {
                bottom: 5px;
            }
            
            .mobileBtn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            
            .mobileBtn.launch {
                width: 60px;
                height: 60px;
                font-size: 10px;
            }
            
            #topUI {
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Top UI Panel - Outside Canvas -->
        <div id="topUI">
            <div class="uiPanel" style="border-color: #3498db;" id="p1Panel">
                <div style="color: #3498db; font-weight: bold;" id="p1Label">PLAYER 1</div>
                <div><strong>SCORE:</strong> <span id="p1Score">0</span></div>
                <div><strong>TRASH:</strong> <span id="p1Trash">0</span></div>
            </div>
            
            <div class="uiPanel">
                <div><strong>TIME:</strong> <span id="timeValue">180</span>s</div>
                <div><strong>GOAL:</strong> <span id="goalValue">100</span> points</div>
                <div><strong>FISH SAVED:</strong> <span id="fishProtected">0</span></div>
                <div><strong>COLLISIONS:</strong> <span id="collisionCount">0</span></div>
            </div>
            
            <div class="uiPanel" style="border-color: #e74c3c;" id="p2Panel">
                <div style="color: #e74c3c; font-weight: bold;">PLAYER 2</div>
                <div><strong>SCORE:</strong> <span id="p2Score">0</span></div>
                <div><strong>TRASH:</strong> <span id="p2Trash">0</span></div>
            </div>
        </div>
        
        <!-- Canvas Wrapper -->
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        
        <!-- Controls - Outside Canvas -->
        <div id="controls">
            <div id="controlsDisplay">
                <!-- Will be dynamically updated based on game mode -->
            </div>
        </div>
        
        <!-- Mobile Touch Controls -->
        <div id="mobileControls">
            <div class="mobileBtn" id="mobileLeft">◄</div>
            <div class="mobileBtn launch" id="mobileLaunch">LAUNCH</div>
            <div class="mobileBtn" id="mobileRight">►</div>
        </div>
        
        <!-- Old overlay hidden -->
        <div id="uiOverlay" style="display: none;">
        </div>
        
        <div id="endScreen">
            <h2 id="endTitle">LEVEL COMPLETE!</h2>
            <div id="endStats">
                <div style="color: #3498db;">Player 1 Score: <span id="p1FinalScore">0</span> (<span id="p1FinalTrash">0</span> trash)</div>
                <div style="color: #e74c3c;">Player 2 Score: <span id="p2FinalScore">0</span> (<span id="p2FinalTrash">0</span> trash)</div>
                <div style="margin-top: 10px;">Fish Saved: <span id="finalFish">0</span></div>
                <div>Performance: <span id="performanceRating">C</span></div>
            </div>
            <div class="factBox" id="endFact">
                <!-- Fact will be inserted here -->
            </div>
            <div id="cycleImageContainer" style="display: none; margin: 20px 0;">
                <img id="cycleImage" src="assets/cycle.png" alt="Plastic Cycle" style="max-width: 100%; height: auto; border-radius: 8px; border: 2px solid #e74c3c;">
                <div style="font-size: 14px; margin-top: 10px; color: #bdc3c7; line-height: 1.6;">
                    <strong>THE PLASTIC CYCLE:</strong><br>
                    Human dumps plastic → Fish eats plastic → Human catches fish → Human eats fish → Microplastics in human body → Human gets sick
                </div>
            </div>
            <div>
                <button id="nextLevelBtn">Next Level</button>
                <button id="retryBtn">Play Again</button>
            </div>
        </div>
        
        <div id="modeScreen">
            <h1>🌊 OCEAN CLEANUP CHALLENGE</h1>
            <h2 style="color: #3498db; font-size: 20px; margin: 10px 0;">Level 1: South China Sea Protection</h2>
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px 0; max-width: 600px; margin-left: auto; margin-right: auto;">
                <p style="font-size: 16px; line-height: 1.6; margin-bottom: 10px;">
                    🌍 <strong>THE CHALLENGE:</strong> Vietnam's coastal waters face severe plastic pollution.<br>
                    Over <strong>280,000 tons of plastic waste</strong> enter the South China Sea annually,<br>
                    threatening marine ecosystems and coastal communities.
                </p>
                <p style="font-size: 14px; color: #3498db; margin-top: 15px;">
                    ♻️ Your mission: Clean the ocean, protect marine life, and learn about sustainable practices!
                </p>
            </div>
            <div style="margin: 30px 0;">
                <h2 style="color: #3498db; font-size: 22px; margin-bottom: 20px;">SELECT GAME MODE</h2>
                <button id="singlePlayerBtn" style="margin: 10px; padding: 20px 40px; font-size: 18px; background: #3498db;">
                    🎮 SINGLE PLAYER<br>
                    <span style="font-size: 12px;">Beat the clock and reach the goal!</span>
                </button>
                <br>
                <button id="multiPlayerBtn" style="margin: 10px; padding: 20px 40px; font-size: 18px; background: #e74c3c;">
                    👥 MULTIPLAYER<br>
                    <span style="font-size: 12px;">Compete with a friend to save more!</span>
                </button>
            </div>
            <div style="margin-top: 20px; font-size: 13px; color: #95a5a6; max-width: 500px; margin-left: auto; margin-right: auto;">
                <em>This game raises awareness about ocean pollution and promotes environmental action in Vietnam's coastal regions.</em>
            </div>
        </div>
        
        <div id="startScreen" style="display: none;">
            <h1>🌊 OCEAN CLEANUP CHALLENGE</h1>
            <h2 style="color: #3498db; margin-bottom: 15px;">Mission Briefing</h2>
            <p id="modeDescription" style="max-width: 600px; margin: 0 auto 20px; font-size: 15px; line-height: 1.6;">Welcome to Level 1: South China Sea Cleanup!</p>
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px auto; max-width: 600px;">
                <h3 style="color: #2ecc71; font-size: 18px; margin-bottom: 10px;">🎯 YOUR MISSION:</h3>
                <div id="missionInfo" style="font-size: 14px; color: #ecf0f1; text-align: left;">
                    <!-- Mission info will be dynamically added here -->
                </div>
            </div>
            <div id="controlsInfo" style="margin: 20px auto; max-width: 600px; background: rgba(52,152,219,0.2); padding: 15px; border-radius: 8px;">
                <!-- Controls will be dynamically added here -->
            </div>
            <button id="startBtn" style="font-size: 20px; padding: 15px 50px; margin-top: 10px;">🚀 START MISSION</button>
            <button id="backBtn" style="background: #95a5a6; margin-top: 10px;">← BACK TO MENU</button>
        </div>
    </div>

    <script>
        // Game Constants - EASIER SETTINGS
        const LEVEL_GOAL = 100; // Much easier goal
        const LEVEL_TIME = 60; // 3 minutes in seconds
        const OCEAN_SURFACE = 200; // 20% of canvas height (600 * 0.2) - no objects above this line
        
        // Load Assets
        const assets = {
            boat: new Image(),
            bottle: new Image(),
            fish: new Image(),
            grabber: new Image(),
            plastic: new Image(),
            turtle: new Image(),
            background: new Image(),
            cycle: new Image()
        };
        
        // Load all images
        assets.boat.src = 'assets/boat.png';
        assets.bottle.src = 'assets/bottle.png';
        assets.fish.src = 'assets/fish.png';
        assets.grabber.src = 'assets/grabber.png';
        assets.plastic.src = 'assets/plastic.png';
        assets.turtle.src = 'assets/turtle.png';
        assets.background.src = 'assets/V2.png';
        assets.cycle.src = 'assets/cycle.png';
        
        // Load Background Music
        const bgMusic = new Audio('SFX/Sea.mp3');
        bgMusic.loop = true; // Loop forever
        bgMusic.volume = 0.5; // Maximum volume (200% louder - browser max is 1.0)
        
        // Load Catch Sound Effect
        const catchSound = new Audio('SFX/Catch.mp3');
        catchSound.volume = 1.0; // Maximum volume (200% louder)
        
        // Load Success Sound Effect
        const successSound = new Audio('SFX/Success.mp3');
        successSound.volume = 1.0; // Maximum volume
        
        let assetsLoaded = 0;
        const totalAssets = Object.keys(assets).length;
        
        // Track asset loading
        Object.values(assets).forEach(img => {
            img.onload = () => {
                assetsLoaded++;
            };
        });
        
        // Game Mode
        let gameMode = 'single'; // 'single' or 'multiplayer'
        
        // Game State
        let gameState = {
            p1Score: 0,
            p1Trash: 0,
            p2Score: 0,
            p2Trash: 0,
            timeLeft: LEVEL_TIME,
            fishProtected: 0,
            collisions: 0,
            gameActive: false,
            gameOver: false,
            winner: null
        };
        
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const modeScreen = document.getElementById('modeScreen');
        const startScreen = document.getElementById('startScreen');
        const endScreen = document.getElementById('endScreen');
        const singlePlayerBtn = document.getElementById('singlePlayerBtn');
        const multiPlayerBtn = document.getElementById('multiPlayerBtn');
        const startBtn = document.getElementById('startBtn');
        const backBtn = document.getElementById('backBtn');
        const retryBtn = document.getElementById('retryBtn');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const modeDescription = document.getElementById('modeDescription');
        const controlsInfo = document.getElementById('controlsInfo');
        const missionInfo = document.getElementById('missionInfo');
        
        // UI Elements
        const p1Score = document.getElementById('p1Score');
        const p2Score = document.getElementById('p2Score');
        const p1Trash = document.getElementById('p1Trash');
        const p2Trash = document.getElementById('p2Trash');
        const timeValue = document.getElementById('timeValue');
        const fishProtected = document.getElementById('fishProtected');
        const collisionCount = document.getElementById('collisionCount');
        
        // End Screen Elements
        const endTitle = document.getElementById('endTitle');
        const p1FinalScore = document.getElementById('p1FinalScore');
        const p2FinalScore = document.getElementById('p2FinalScore');
        const p1FinalTrash = document.getElementById('p1FinalTrash');
        const p2FinalTrash = document.getElementById('p2FinalTrash');
        const finalFish = document.getElementById('finalFish');
        const performanceRating = document.getElementById('performanceRating');
        const endFact = document.getElementById('endFact');
        
        // Game Objects - Two Players
        let boat1 = {
            x: canvas.width / 4,
            y: OCEAN_SURFACE - 10,
            width: 80,
            height: 40,
            speed: 3,
            canMove: true,
            color: '#3498db' // Blue for P1
        };
        
        let boat2 = {
            x: (canvas.width / 4) * 3,
            y: OCEAN_SURFACE - 10,
            width: 80,
            height: 40,
            speed: 3,
            canMove: true,
            color: '#e74c3c' // Red for P2
        };
        
        let grabber1 = {
            angle: 0,
            length: 60,
            maxLength: 400,
            extensionSpeed: 2.5,
            retractionSpeed: 2.5,
            swingSpeed: 0.01,
            state: 'swinging',
            carrying: null,
            tipX: 0,
            tipY: 0,
            player: 1
        };
        
        let grabber2 = {
            angle: 0,
            length: 60,
            maxLength: 400,
            extensionSpeed: 2.5,
            retractionSpeed: 2.5,
            swingSpeed: 0.01,
            state: 'swinging',
            carrying: null,
            tipX: 0,
            tipY: 0,
            player: 2
        };
        
        let trashItems = [];
        let marineLife = [];
        let effects = [];
        
        // Trash Types - HIGHER POINTS, EASIER TO CATCH
        const TRASH_TYPES = {
            BOTTLE: { points: 10, weight: 1, radius: 20, color: '#FF6B6B', name: 'Plastic Bottle', asset: 'bottle' },
            PLASTIC: { points: 15, weight: 0.5, radius: 22, color: '#4ECDC4', name: 'Plastic Bag', asset: 'plastic' }
        };
        
        // Marine Life Types - REDUCED PENALTIES
        const MARINE_LIFE_TYPES = {
            FISH: { penalty: 30, radius: 25, color: '#1DD3B0', speed: 0.3, name: 'Fish', asset: 'fish' },
            TURTLE: { penalty: 50, radius: 30, color: '#AFFC41', speed: 0.2, name: 'Turtle', asset: 'turtle' }
        };
        
        // Initialize Game
        function initGame() {
            gameState = {
                p1Score: 0,
                p1Trash: 0,
                p2Score: 0,
                p2Trash: 0,
                timeLeft: LEVEL_TIME,
                fishProtected: 0,
                collisions: 0,
                gameActive: true,
                gameOver: false,
                winner: null
            };
            
            // Configure UI based on game mode
            const p1Label = document.getElementById('p1Label');
            const p2Panel = document.getElementById('p2Panel');
            const controlsDisplay = document.getElementById('controlsDisplay');
            
            if (gameMode === 'single') {
                // Single player mode
                p1Label.textContent = 'YOUR SCORE';
                p2Panel.style.display = 'none';
                controlsDisplay.innerHTML = '<span class="key">A/D</span> or <span class="key">←/→</span> to move | <span class="key">SPACEBAR</span> to launch';
                
                // Position boat in center for single player
                boat1.x = canvas.width / 2;
                boat2.x = -1000; // Move P2 off screen
            } else {
                // Multiplayer mode
                p1Label.textContent = 'PLAYER 1';
                p2Panel.style.display = 'block';
                controlsDisplay.innerHTML = '<span style="color: #3498db;">P1:</span> <span class="key">A/D</span> + <span class="key">SPACE</span> | <span style="color: #e74c3c;">P2:</span> <span class="key">←/→</span> + <span class="key">ENTER</span>';
                
                // Position boats for multiplayer
                boat1.x = canvas.width / 4;
                boat2.x = (canvas.width / 4) * 3;
            }
            
            // Reset Player 1
            boat1.y = OCEAN_SURFACE - 10;
            boat1.canMove = true;
            grabber1 = {
                angle: 0,
                length: 60,
                maxLength: 400,
                extensionSpeed: 2.5,
                retractionSpeed: 2.5,
                swingSpeed: 0.01,
                state: 'swinging',
                carrying: null,
                tipX: 0,
                tipY: 0,
                player: 1
            };
            
            // Reset Player 2
            boat2.y = OCEAN_SURFACE - 10;
            boat2.canMove = true;
            grabber2 = {
                angle: 0,
                length: 60,
                maxLength: 400,
                extensionSpeed: 2.5,
                retractionSpeed: 2.5,
                swingSpeed: 0.01,
                state: 'swinging',
                carrying: null,
                tipX: 0,
                tipY: 0,
                player: 2
            };
            
            trashItems = [];
            marineLife = [];
            effects = [];
            
            // Spawn 10-15 trash items
            const trashCount = 10 + Math.floor(Math.random() * 6);
            for (let i = 0; i < trashCount; i++) {
                spawnTrash();
            }
            
            // Spawn 10-15 marine life
            const marineCount = 10 + Math.floor(Math.random() * 6);
            for (let i = 0; i < marineCount; i++) {
                spawnMarineLife();
            }
            
            updateUI();
            startScreen.style.display = 'none';
            endScreen.style.display = 'none';
            
            // Start background music
            bgMusic.play().catch(err => console.log('Audio autoplay prevented:', err));
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Spawn Trash
        function spawnTrash() {
            const types = Object.keys(TRASH_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            const trashConfig = TRASH_TYPES[type];
            
            let x, y;
            let validPosition = false;
            let attempts = 0;
            
            // Find valid position (not too close to other objects)
            // Spawn below ocean surface (OCEAN_SURFACE to canvas.height)
            while (!validPosition && attempts < 50) {
                x = Math.random() * (canvas.width - 100) + 50;
                y = Math.random() * (canvas.height - OCEAN_SURFACE - 100) + OCEAN_SURFACE + 50;
                
                validPosition = true;
                
                // Check distance from other trash
                for (let trash of trashItems) {
                    const distance = Math.sqrt((trash.x - x)**2 + (trash.y - y)**2);
                    if (distance < 80) { // Increased from 60
                        validPosition = false;
                        break;
                    }
                }
                
                // Check distance from marine life
                for (let life of marineLife) {
                    const distance = Math.sqrt((life.x - x)**2 + (life.y - y)**2);
                    if (distance < 80) { // Increased from 60
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                trashItems.push({
                    x: x,
                    y: y,
                    type: type,
                    config: trashConfig,
                    vx: (Math.random() - 0.5) * 0.3, // Reduced from 0.5
                    vy: (Math.random() - 0.5) * 0.3  // Reduced from 0.5
                });
            }
        }
        
        // Spawn Marine Life
        function spawnMarineLife() {
            const types = Object.keys(MARINE_LIFE_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            const lifeConfig = MARINE_LIFE_TYPES[type];
            
            let x, y;
            let validPosition = false;
            let attempts = 0;
            
            // Spawn below ocean surface (OCEAN_SURFACE to canvas.height)
            while (!validPosition && attempts < 50) {
                x = Math.random() * (canvas.width - 100) + 50;
                y = Math.random() * (canvas.height - OCEAN_SURFACE - 100) + OCEAN_SURFACE + 50;
                
                validPosition = true;
                
                // Check distance from other marine life
                for (let life of marineLife) {
                    const distance = Math.sqrt((life.x - x)**2 + (life.y - y)**2);
                    if (distance < 100) { // Increased from 80
                        validPosition = false;
                        break;
                    }
                }
                
                // Check distance from trash
                for (let trash of trashItems) {
                    const distance = Math.sqrt((trash.x - x)**2 + (trash.y - y)**2);
                    if (distance < 100) { // Increased from 80
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                marineLife.push({
                    x: x,
                    y: y,
                    type: type,
                    config: lifeConfig,
                    vx: (Math.random() - 0.5) * lifeConfig.speed,
                    vy: (Math.random() - 0.5) * lifeConfig.speed,
                    isPolluted: false,
                    pollutionTimer: 0
                });
            }
        }
        
        // Update Game State
        function updateGame() {
            if (!gameState.gameActive) return;
            
            // Update Player 1 grabber (always)
            updateGrabber(grabber1, boat1, 1);
            
            // Update Player 2 grabber (only in multiplayer)
            if (gameMode === 'multiplayer') {
                updateGrabber(grabber2, boat2, 2);
            }
            
            // Update trash items
            updateTrash();
            
            // Update marine life
            updateMarineLife();
            
            // Update effects
            updateEffects();
            
            // Check collisions between trash and marine life
            checkCollisions();
            
            // Update timer
            gameState.timeLeft -= 1/60; // Assuming 60 FPS
            
            // Check game over conditions
            if (gameState.timeLeft <= 0) {
                endGame();
            }
            
            if (gameState.p1Score >= LEVEL_GOAL) {
                gameState.winner = 1;
                endGame();
            }
            
            // Only check Player 2 score in multiplayer mode
            if (gameMode === 'multiplayer' && gameState.p2Score >= LEVEL_GOAL) {
                gameState.winner = 2;
                endGame();
            }
            
            // Update UI
            updateUI();
        }
        
        // Update Grabber - Works for both players
        function updateGrabber(grabber, boat, playerNum) {
            if (grabber.state === 'swinging') {
                // Swing the hook back and forth
                grabber.angle += grabber.swingSpeed;
                if (grabber.angle > Math.PI / 3 || grabber.angle < -Math.PI / 3) {
                    grabber.swingSpeed *= -1;
                }
                
                // Calculate tip position for swinging
                grabber.tipX = boat.x + Math.sin(grabber.angle) * grabber.length;
                grabber.tipY = boat.y + Math.cos(grabber.angle) * grabber.length;
                
                // Boat can move
                boat.canMove = true;
                
            } else if (grabber.state === 'extending') {
                // Boat cannot move when hook is launched
                boat.canMove = false;
                
                // Extend hook in the direction it was launched
                grabber.tipX += Math.sin(grabber.angle) * grabber.extensionSpeed;
                grabber.tipY += Math.cos(grabber.angle) * grabber.extensionSpeed;
                
                // Calculate current length
                const dx = grabber.tipX - boat.x;
                const dy = grabber.tipY - boat.y;
                grabber.length = Math.sqrt(dx * dx + dy * dy);
                
                // Check collision with trash (improved accuracy)
                if (!grabber.carrying) {
                    for (let i = 0; i < trashItems.length; i++) {
                        const trash = trashItems[i];
                        const dist = Math.sqrt(
                            (grabber.tipX - trash.x) * (grabber.tipX - trash.x) +
                            (grabber.tipY - trash.y) * (grabber.tipY - trash.y)
                        );
                        
                        if (dist < trash.config.radius + 15) { // More forgiving collision
                            grabber.carrying = trash;
                            trashItems.splice(i, 1);
                            grabber.state = 'retracting';
                            const color = playerNum === 1 ? '#3498db' : '#e74c3c';
                            createEffect(trash.x, trash.y, '+' + trash.config.points, color);
                            
                            // Play catch sound effect
                            catchSound.currentTime = 0; // Reset to start for rapid catches
                            catchSound.play().catch(err => console.log('Catch sound error:', err));
                            
                            break;
                        }
                    }
                }
                
                // Check if hit bottom or max length
                if (grabber.tipY >= canvas.height - 20 || grabber.length >= grabber.maxLength) {
                    grabber.state = 'retracting';
                }
                
            } else if (grabber.state === 'retracting') {
                // Boat still cannot move
                boat.canMove = false;
                
                // Retract hook back to boat
                const dx = boat.x - grabber.tipX;
                const dy = boat.y - grabber.tipY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    grabber.tipX += (dx / dist) * grabber.retractionSpeed;
                    grabber.tipY += (dy / dist) * grabber.retractionSpeed;
                    grabber.length = dist;
                    
                    // Update carried trash position
                    if (grabber.carrying) {
                        grabber.carrying.x = grabber.tipX;
                        grabber.carrying.y = grabber.tipY;
                    }
                } else {
                    // Hook returned to boat
                    if (grabber.carrying) {
                        // Update appropriate player's score
                        if (playerNum === 1) {
                            gameState.p1Score += grabber.carrying.config.points;
                            gameState.p1Trash++;
                        } else {
                            gameState.p2Score += grabber.carrying.config.points;
                            gameState.p2Trash++;
                        }
                        const color = playerNum === 1 ? '#3498db' : '#e74c3c';
                        createEffect(boat.x, boat.y, '+' + grabber.carrying.config.points, color);
                        
                        // Spawn new trash to replace collected one
                        spawnTrash();
                    }
                    
                    // Reset hook to swinging state
                    grabber.state = 'swinging';
                    grabber.carrying = null;
                    grabber.length = 60;
                    grabber.angle = 0;
                    grabber.swingSpeed = 0.01;
                    boat.canMove = true;
                }
            }
        }
        
        // Update Trash Items
        function updateTrash() {
            for (let i = 0; i < trashItems.length; i++) {
                const trash = trashItems[i];
                
                // Move trash with slight drift
                trash.x += trash.vx;
                trash.y += trash.vy;
                
                // Bounce off walls
                if (trash.x < trash.config.radius || trash.x > canvas.width - trash.config.radius) {
                    trash.vx *= -1;
                }
                // Keep trash below ocean surface and above bottom
                if (trash.y < OCEAN_SURFACE + trash.config.radius || trash.y > canvas.height - trash.config.radius) {
                    trash.vy *= -1;
                }
            }
        }
        
        // Update Marine Life
        function updateMarineLife() {
            for (let life of marineLife) {
                // Move marine life
                life.x += life.vx;
                life.y += life.vy;
                
                // Bounce off walls with some randomness
                if (life.x < life.config.radius || life.x > canvas.width - life.config.radius) {
                    life.vx *= -1;
                    life.vx += (Math.random() - 0.5) * 0.3; // Reduced from 0.5
                }
                // Keep marine life below ocean surface and above bottom
                if (life.y < OCEAN_SURFACE + life.config.radius || life.y > canvas.height - life.config.radius) {
                    life.vy *= -1;
                    life.vy += (Math.random() - 0.5) * 0.3; // Reduced from 0.5
                }
                
                // Limit speed
                const speed = Math.sqrt(life.vx**2 + life.vy**2);
                if (speed > life.config.speed) {
                    life.vx = (life.vx / speed) * life.config.speed;
                    life.vy = (life.vy / speed) * life.config.speed;
                }
                
                // Update pollution timer
                if (life.isPolluted) {
                    life.pollutionTimer--;
                    if (life.pollutionTimer <= 0) {
                        life.isPolluted = false;
                    }
                }
            }
        }
        
        // Check Collisions between Trash and Marine Life
        function checkCollisions() {
            for (let i = 0; i < trashItems.length; i++) {
                const trash = trashItems[i];
                
                for (let j = 0; j < marineLife.length; j++) {
                    const life = marineLife[j];
                    
                    const distance = Math.sqrt((trash.x - life.x)**2 + (trash.y - life.y)**2);
                    
                    if (distance < trash.config.radius + life.config.radius + 5) { // Added buffer
                        // Collision detected - trash harms marine life
                        gameState.score -= life.config.penalty;
                        gameState.collisions++;
                        life.isPolluted = true;
                        life.pollutionTimer = 180; // 3 seconds at 60 FPS
                        
                        // Create collision effect
                        createEffect(life.x, life.y, '-'+life.config.penalty, '#e74c3c');
                        createCollisionEffect(life.x, life.y);
                        
                        // Remove the trash (marine life "ate" it)
                        trashItems.splice(i, 1);
                        i--; // Adjust index after removal
                        break;
                    }
                }
            }
            
            // Update fish protected count (non-polluted fish)
            gameState.fishProtected = marineLife.filter(life => !life.isPolluted).length;
        }
        
        // Create Text Effect
        function createEffect(x, y, text, color) {
            effects.push({
                x: x,
                y: y,
                text: text,
                color: color,
                life: 60, // 1 second at 60 FPS
                vy: -1 // Float upward
            });
        }
        
        // Create Collision Effect
        function createCollisionEffect(x, y) {
            effects.push({
                x: x,
                y: y,
                type: 'collision',
                life: 30, // 0.5 seconds
                size: 10,
                maxSize: 40
            });
        }
        
        // Update Effects
        function updateEffects() {
            for (let i = 0; i < effects.length; i++) {
                const effect = effects[i];
                
                if (effect.type === 'collision') {
                    effect.size += 1;
                } else {
                    effect.y += effect.vy;
                }
                
                effect.life--;
                
                if (effect.life <= 0) {
                    effects.splice(i, 1);
                    i--;
                }
            }
        }
        
        // Update UI
        function updateUI() {
            p1Score.textContent = gameState.p1Score;
            p2Score.textContent = gameState.p2Score;
            p1Trash.textContent = gameState.p1Trash;
            p2Trash.textContent = gameState.p2Trash;
            timeValue.textContent = Math.max(0, Math.ceil(gameState.timeLeft));
            fishProtected.textContent = gameState.fishProtected;
            collisionCount.textContent = gameState.collisions;
        }
        
        // End Game
        function endGame() {
            gameState.gameActive = false;
            gameState.gameOver = true;
            
            // Stop background music
            bgMusic.pause();
            bgMusic.currentTime = 0;
            
            // Calculate performance rating
            const efficiency = gameState.fishProtected / (gameState.fishProtected + gameState.collisions) || 0;
            let rating = 'C';
            if (efficiency >= 0.7) rating = 'A';
            else if (efficiency >= 0.5) rating = 'B';
            
            const cycleImageContainer = document.getElementById('cycleImageContainer');
            let didFail = false;
            
            // Update end screen based on game mode
            if (gameMode === 'single') {
                // Single player mode
                if (gameState.p1Score >= LEVEL_GOAL) {
                    endTitle.textContent = '🎉 LEVEL COMPLETE! 🎉';
                    endTitle.style.color = '#2ecc71';
                    didFail = false;
                    
                    // Play success sound
                    successSound.currentTime = 0;
                    successSound.play().catch(err => console.log('Success sound error:', err));
                } else {
                    endTitle.textContent = '💔 TIME\'S UP!';
                    endTitle.style.color = '#e74c3c';
                    didFail = true;
                }
            } else {
                // Multiplayer mode - Determine winner
                if (!gameState.winner) {
                    // Time ran out - compare scores
                    if (gameState.p1Score > gameState.p2Score) {
                        gameState.winner = 1;
                    } else if (gameState.p2Score > gameState.p1Score) {
                        gameState.winner = 2;
                    } else {
                        gameState.winner = 0; // Tie
                    }
                }
                
                if (gameState.winner === 1) {
                    endTitle.textContent = '🎉 PLAYER 1 WINS! 🎉';
                    endTitle.style.color = '#3498db';
                    
                    // Play success sound for winner
                    successSound.currentTime = 0;
                    successSound.play().catch(err => console.log('Success sound error:', err));
                } else if (gameState.winner === 2) {
                    endTitle.textContent = '🎉 PLAYER 2 WINS! 🎉';
                    endTitle.style.color = '#e74c3c';
                    
                    // Play success sound for winner
                    successSound.currentTime = 0;
                    successSound.play().catch(err => console.log('Success sound error:', err));
                } else {
                    endTitle.textContent = '🤝 TIE GAME! 🤝';
                    endTitle.style.color = '#f39c12';
                }
                
                // Show cycle for multiplayer only if someone lost badly or low scores
                didFail = (gameState.p1Score < 50 && gameState.p2Score < 50);
            }
            
            // Show different facts based on outcome
            if (didFail || gameState.collisions > 5) {
                // Show warning message with cycle diagram
                endFact.innerHTML = `
                    <strong>⚠️ ENVIRONMENTAL IMPACT - VIETNAM'S CHALLENGE:</strong><br>
                    "Vietnam is among the top 10 countries contributing to ocean plastic pollution globally. 
                    When fish ingest microplastics in the South China Sea Sea, these toxins enter our food chain. 
                    Studies show Vietnamese seafood contains alarming levels of microplastics, 
                    posing serious health risks to coastal communities."<br><br>
                    <strong>🐟 THE DANGEROUS CYCLE:</strong><br>
                    "An estimated <strong>74,000 tons of plastic</strong> enter Vietnam's coastal waters each year. 
                    This affects 3,200+ marine species and ultimately impacts human health through seafood consumption.<br>
                    <em>Source: World Bank & Vietnam Environment Administration, 2024</em>"
                `;
                cycleImageContainer.style.display = 'block';
            } else {
                // Show positive message without cycle
                endFact.innerHTML = `
                    <strong>🌊 EXCELLENT WORK - MAKING A DIFFERENCE!</strong><br>
                    "Vietnam has committed to reducing ocean plastic by 50% by 2025 and eliminating it by 2030. 
                    Your cleanup efforts represent the important work being done by local communities, 
                    environmental organizations, and government initiatives to protect our seas."<br><br>
                    <strong>💪 REAL-WORLD IMPACT:</strong><br>
                    "Every piece of plastic removed prevents harm to marine life. Organizations like Ocean Conservancy 
                    have collected over 500,000 kg of waste from Vietnam's beaches in recent years. 
                    Small actions create big change!<br>
                    <em>Together, we can achieve a cleaner South China Sea! 🌍</em>"
                `;
                cycleImageContainer.style.display = 'none';
            }
            
            p1FinalScore.textContent = gameState.p1Score;
            p2FinalScore.textContent = gameState.p2Score;
            p1FinalTrash.textContent = gameState.p1Trash;
            p2FinalTrash.textContent = gameState.p2Trash;
            finalFish.textContent = gameState.fishProtected;
            performanceRating.textContent = rating;
            
            // Show Next Level button only if player won
            if (gameMode === 'single') {
                // Show button if single player reached the goal
                nextLevelBtn.style.display = (gameState.p1Score >= LEVEL_GOAL) ? 'inline-block' : 'none';
            } else {
                // Show button if either player won in multiplayer
                nextLevelBtn.style.display = (gameState.winner === 1 || gameState.winner === 2) ? 'inline-block' : 'none';
            }
            
            endScreen.style.display = 'block';
        }
        
        // Draw Game
        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background image if loaded
            if (assets.background.complete && assets.background.naturalWidth > 0) {
                ctx.drawImage(assets.background, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: Draw water background with gradient
                const waterGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                waterGradient.addColorStop(0, '#1e3c72');
                waterGradient.addColorStop(0.2, '#2a5298'); // Ocean surface at 20%
                waterGradient.addColorStop(1, '#1a3a52');
                ctx.fillStyle = waterGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw water surface line at OCEAN_SURFACE
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, OCEAN_SURFACE);
                ctx.lineTo(canvas.width, OCEAN_SURFACE);
                ctx.stroke();
            }
            
            // Draw trash items
            for (let trash of trashItems) {
                drawTrash(trash);
            }
            
            // Draw marine life
            for (let life of marineLife) {
                drawMarineLife(life);
            }
            
            // Draw Player 1 (always)
            drawBoat(boat1, '#3498db');
            drawGrabber(grabber1, boat1, '#3498db');
            
            // Draw Player 2 (only in multiplayer mode)
            if (gameMode === 'multiplayer') {
                drawBoat(boat2, '#e74c3c');
                drawGrabber(grabber2, boat2, '#e74c3c');
            }
            
            // Draw effects
            for (let effect of effects) {
                drawEffect(effect);
            }
            
            // Draw carried items
            if (grabber1.carrying) {
                drawTrash(grabber1.carrying);
            }
            if (gameMode === 'multiplayer' && grabber2.carrying) {
                drawTrash(grabber2.carrying);
            }
        }
        
        // Draw Boat with Asset Image
        function drawBoat(boat, playerColor) {
            ctx.save();
            if (assets.boat.complete && assets.boat.naturalWidth > 0) {
                ctx.drawImage(assets.boat, boat.x - boat.width/2, boat.y - boat.height/2, boat.width, boat.height);
            } else {
                // Fallback if image not loaded
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(boat.x - 30, boat.y, 60, 20);
                ctx.fillStyle = '#A52A2A';
                ctx.fillRect(boat.x - 25, boat.y, 50, 8);
                ctx.fillStyle = '#CD5C5C';
                ctx.fillRect(boat.x - 15, boat.y - 15, 30, 15);
            }
            ctx.restore();
            
            // Boat outline with player color
            ctx.strokeStyle = playerColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(boat.x - 30, boat.y, 60, 20);
            ctx.strokeRect(boat.x - 15, boat.y - 15, 30, 15);
        }
        
        // Draw Grabber with Asset Image
        function drawGrabber(grabber, boat, playerColor) {
            // Draw rope with player color
            ctx.strokeStyle = playerColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(boat.x, boat.y + 5);
            ctx.lineTo(grabber.tipX, grabber.tipY);
            ctx.stroke();
            
            // Draw grabber hook using asset
            ctx.save();
            if (assets.grabber.complete && assets.grabber.naturalWidth > 0) {
                const grabberSize = 30;
                ctx.drawImage(assets.grabber, grabber.tipX - grabberSize/2, grabber.tipY - grabberSize/2, grabberSize, grabberSize);
            } else {
                // Fallback
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(grabber.tipX, grabber.tipY, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = playerColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(grabber.tipX, grabber.tipY, 10, 0.5, Math.PI - 0.5);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // Draw Trash with Asset Images
        function drawTrash(trash) {
            ctx.save();
            
            // Use asset images
            const asset = trash.config.asset;
            if (asset && assets[asset] && assets[asset].complete && assets[asset].naturalWidth > 0) {
                const size = trash.config.radius * 2;
                ctx.drawImage(assets[asset], trash.x - size/2, trash.y - size/2, size, size);
            } else {
                // Fallback to colored circles
                ctx.fillStyle = trash.config.color;
                ctx.beginPath();
                ctx.arc(trash.x, trash.y, trash.config.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
            
            // OLD CODE - Now handled by images
            switch(trash.type) {
                case 'BOTTLE_OLD':
                    // Draw bottle (pixel art)
                    ctx.fillRect(trash.x - 6, trash.y - 12, 12, 24);
                    // Bottle cap
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(trash.x - 4, trash.y - 14, 8, 2);
                    // Liquid
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(trash.x - 4, trash.y - 8, 8, 16);
                    break;
                    
                case 'BAG':
                    // Draw bag (pixel art)
                    ctx.beginPath();
                    ctx.moveTo(trash.x - 10, trash.y);
                    ctx.lineTo(trash.x, trash.y - 8);
                    ctx.lineTo(trash.x + 10, trash.y);
                    ctx.lineTo(trash.x, trash.y + 8);
                    ctx.closePath();
                    ctx.fill();
                    // Bag handles
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(trash.x - 6, trash.y - 2, 4, 0, Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(trash.x + 6, trash.y - 2, 4, 0, Math.PI);
                    ctx.stroke();
                    break;
                    
                case 'CONTAINER':
                    // Draw container (pixel art)
                    ctx.fillRect(trash.x - 10, trash.y - 7, 20, 14);
                    // Container lid
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(trash.x - 8, trash.y - 9, 16, 2);
                    // Food
                    ctx.fillStyle = '#FF6B6B';
                    ctx.fillRect(trash.x - 6, trash.y - 5, 12, 8);
                    break;
                    
                case 'STRAW':
                    // Draw straw (pixel art)
                    ctx.fillRect(trash.x - 2, trash.y - 8, 4, 16);
                    // Straw stripe
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(trash.x - 2, trash.y - 6, 4, 2);
                    ctx.fillRect(trash.x - 2, trash.y, 4, 2);
                    ctx.fillRect(trash.x - 2, trash.y + 6, 4, 2);
                    break;
            }
            
            // Pixel art outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            switch(trash.type) {
                case 'BOTTLE':
                    ctx.strokeRect(trash.x - 6, trash.y - 12, 12, 24);
                    break;
                case 'BAG':
                    ctx.stroke();
                    break;
                case 'CONTAINER':
                    ctx.strokeRect(trash.x - 10, trash.y - 7, 20, 14);
                    break;
                case 'STRAW':
                    ctx.strokeRect(trash.x - 2, trash.y - 8, 4, 16);
                    break;
            }
        }
        
        // Draw Marine Life with Asset Images
        function drawMarineLife(life) {
            ctx.save();
            
            // Apply pollution effect if contaminated
            if (life.isPolluted) {
                ctx.globalAlpha = 0.5;
                ctx.filter = 'grayscale(70%)';
            }
            
            // Use asset images
            const asset = life.config.asset;
            if (asset && assets[asset] && assets[asset].complete && assets[asset].naturalWidth > 0) {
                const size = life.config.radius * 2;
                
                // Flip horizontally based on movement direction
                if (life.vx < 0) {
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(assets[asset], -life.x - size/2, life.y - size/2, size, size);
                    ctx.restore();
                } else {
                    ctx.drawImage(assets[asset], life.x - size/2, life.y - size/2, size, size);
                }
            } else {
                // Fallback to colored shapes
                ctx.fillStyle = life.isPolluted ? '#8B008B' : life.config.color;
                ctx.beginPath();
                ctx.arc(life.x, life.y, life.config.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
            return; // Skip old drawing code
            
            // OLD CODE BELOW - keeping for reference
            switch(life.type) {
                case 'FISH_OLD':
                    // Draw fish body (pixel art)
                    ctx.beginPath();
                    ctx.ellipse(life.x, life.y, 12, 8, Math.atan2(life.vy, life.vx), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw tail (pixel art)
                    ctx.beginPath();
                    const tailAngle = Math.atan2(life.vy, life.vx);
                    const tailX = life.x - Math.cos(tailAngle) * 12;
                    const tailY = life.y - Math.sin(tailAngle) * 12;
                    ctx.moveTo(tailX, tailY);
                    ctx.lineTo(tailX - 8, tailY - 6);
                    ctx.lineTo(tailX - 8, tailY + 6);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw eye (pixel art)
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    const eyeX = life.x + Math.cos(tailAngle) * 6;
                    const eyeY = life.y + Math.sin(tailAngle) * 6;
                    ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw fin (pixel art)
                    ctx.fillStyle = life.config.color;
                    ctx.beginPath();
                    ctx.moveTo(life.x, life.y - 6);
                    ctx.lineTo(life.x + 4, life.y - 10);
                    ctx.lineTo(life.x + 8, life.y - 8);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'TURTLE':
                    // Draw turtle shell (pixel art)
                    ctx.beginPath();
                    ctx.ellipse(life.x, life.y, 15, 10, Math.atan2(life.vy, life.vx), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw shell pattern (pixel art)
                    ctx.strokeStyle = '#2F4F4F';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(life.x, life.y, 12, 8, Math.atan2(life.vy, life.vx), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw head (pixel art)
                    ctx.fillStyle = life.config.color;
                    const headAngle = Math.atan2(life.vy, life.vx);
                    const headX = life.x + Math.cos(headAngle) * 15;
                    const headY = life.y + Math.sin(headAngle) * 15;
                    ctx.beginPath();
                    ctx.arc(headX, headY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw flippers (pixel art)
                    ctx.beginPath();
                    ctx.ellipse(life.x - 8, life.y - 8, 8, 3, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(life.x - 8, life.y + 8, 8, 3, -Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            
            // Outline for pixel art
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            if (life.type === 'FISH') {
                ctx.stroke();
            } else {
                ctx.stroke();
            }
        }
        
        // Draw Effect
        function drawEffect(effect) {
            if (effect.type === 'collision') {
                // Draw collision effect (expanding circle)
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // Draw text effect
                ctx.fillStyle = effect.color;
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(effect.text, effect.x, effect.y);
            }
        }
        
        // Game Loop
        function gameLoop() {
            if (gameState.gameActive && !gameState.gameOver) {
                updateGame();
                drawGame();
                requestAnimationFrame(gameLoop);
            }
        }
        
        // Event Listeners
        // Mode Selection
        singlePlayerBtn.addEventListener('click', function() {
            gameMode = 'single';
            showStartScreen();
        });
        
        multiPlayerBtn.addEventListener('click', function() {
            gameMode = 'multiplayer';
            showStartScreen();
        });
        
        backBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            modeScreen.style.display = 'flex';
        });
        
        startBtn.addEventListener('click', initGame);
        
        retryBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            modeScreen.style.display = 'flex';
        });
        
        nextLevelBtn.addEventListener('click', function() {
            // Navigate to Level 2 with game mode parameter
            window.location.href = 'Level2.html?mode=' + gameMode;
        });
        
        // Show Start Screen with Mode-Specific Info
        function showStartScreen() {
            modeScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            
            if (gameMode === 'single') {
                modeDescription.innerHTML = 'Welcome to <strong>SINGLE PLAYER MODE</strong>!<br>Help clean Vietnam\'s coastal waters and protect marine ecosystems!';
                controlsInfo.innerHTML = `
                    <div style="color: #3498db; margin: 10px 0;">
                        <strong>🎮 CONTROLS:</strong> <span class="key">A</span> <span class="key">D</span> or <span class="key">←</span> <span class="key">→</span> Move Boat | <span class="key">SPACE</span> Launch Grabber
                    </div>
                `;
                missionInfo.innerHTML = `
                    <strong>📋 Objectives:</strong><br>
                    ✓ Collect 100 points worth of plastic waste in 60 seconds<br>
                    ✓ Protect marine life - avoid fish-plastic collisions<br>
                    ✓ Learn about ocean pollution impact in Vietnam<br><br>
                    <em style="color: #f39c12;">⚠️ Each fish-plastic collision harms marine ecosystems!</em>
                `;
            } else {
                modeDescription.innerHTML = 'Welcome to <strong>MULTIPLAYER MODE</strong>!<br>Compete to see who can clean more pollution from the South China Sea!';
                controlsInfo.innerHTML = `
                    <div style="color: #3498db; margin: 10px 0;"><strong>🎮 PLAYER 1:</strong> <span class="key">A</span> <span class="key">D</span> Move | <span class="key">SPACE</span> Launch</div>
                    <div style="color: #e74c3c; margin: 10px 0;"><strong>🎮 PLAYER 2:</strong> <span class="key">←</span> <span class="key">→</span> Move | <span class="key">ENTER</span> Launch</div>
                `;
                missionInfo.innerHTML = `
                    <strong>📋 Competition Rules:</strong><br>
                    ✓ First player to reach 100 points wins!<br>
                    ✓ Compete within 60 seconds time limit<br>
                    ✓ Protect fish - collisions hurt your score<br><br>
                    <em style="color: #2ecc71;">🤝 Teamwork for a cleaner ocean!</em>
                `;
            }
        }
        
        // Keyboard Controls
        const keys = {};
        
        window.addEventListener('keydown', function(e) {
            keys[e.key] = true;
            
            // Player 1: Spacebar to launch grabber
            if (e.key === ' ' && gameState.gameActive && grabber1.state === 'swinging') {
                grabber1.state = 'extending';
                e.preventDefault();
            }
            
            // Player 2: Enter to launch grabber (only in multiplayer mode)
            if (gameMode === 'multiplayer' && e.key === 'Enter' && gameState.gameActive && grabber2.state === 'swinging') {
                grabber2.state = 'extending';
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', function(e) {
            keys[e.key] = false;
        });
        
        // Handle continuous key presses for movement
        function handleInput() {
            if (!gameState.gameActive) return;
            
            if (gameMode === 'single') {
                // Single Player: Can use A/D or Arrow Keys
                if (boat1.canMove) {
                    if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                        boat1.x -= boat1.speed;
                        if (boat1.x < boat1.width/2) boat1.x = boat1.width/2;
                    }
                    
                    if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                        boat1.x += boat1.speed;
                        if (boat1.x > canvas.width - boat1.width/2) boat1.x = canvas.width - boat1.width/2;
                    }
                }
            } else {
                // Multiplayer: Separate controls
                // Player 1 Controls: A/D
                if (boat1.canMove) {
                    if (keys['a'] || keys['A']) {
                        boat1.x -= boat1.speed;
                        if (boat1.x < boat1.width/2) boat1.x = boat1.width/2;
                    }
                    
                    if (keys['d'] || keys['D']) {
                        boat1.x += boat1.speed;
                        if (boat1.x > canvas.width - boat1.width/2) boat1.x = canvas.width - boat1.width/2;
                    }
                }
                
                // Player 2 Controls: Arrow Keys
                if (boat2.canMove) {
                    if (keys['ArrowLeft']) {
                        boat2.x -= boat2.speed;
                        if (boat2.x < boat2.width/2) boat2.x = boat2.width/2;
                    }
                    
                    if (keys['ArrowRight']) {
                        boat2.x += boat2.speed;
                        if (boat2.x > canvas.width - boat2.width/2) boat2.x = canvas.width - boat2.width/2;
                    }
                }
            }
        }
        
        // Input handling in game loop
        const originalGameLoop = gameLoop;
        gameLoop = function() {
            if (gameState.gameActive && !gameState.gameOver) {
                handleInput();
                updateGame();
                drawGame();
                requestAnimationFrame(gameLoop);
            }
        };
        
        // Mobile Touch Controls
        const mobileLeft = document.getElementById('mobileLeft');
        const mobileRight = document.getElementById('mobileRight');
        const mobileLaunch = document.getElementById('mobileLaunch');
        
        let mobileLeftPressed = false;
        let mobileRightPressed = false;
        
        // Touch start events
        mobileLeft.addEventListener('touchstart', function(e) {
            e.preventDefault();
            mobileLeftPressed = true;
            keys['ArrowLeft'] = true;
        });
        
        mobileRight.addEventListener('touchstart', function(e) {
            e.preventDefault();
            mobileRightPressed = true;
            keys['ArrowRight'] = true;
        });
        
        mobileLaunch.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (gameState.gameActive) {
                if (gameMode === 'single' && grabber1.state === 'swinging') {
                    grabber1.state = 'extending';
                }
            }
        });
        
        // Touch end events
        mobileLeft.addEventListener('touchend', function(e) {
            e.preventDefault();
            mobileLeftPressed = false;
            keys['ArrowLeft'] = false;
        });
        
        mobileRight.addEventListener('touchend', function(e) {
            e.preventDefault();
            mobileRightPressed = false;
            keys['ArrowRight'] = false;
        });
        
        // Mouse events for testing on desktop
        mobileLeft.addEventListener('mousedown', function(e) {
            e.preventDefault();
            mobileLeftPressed = true;
            keys['ArrowLeft'] = true;
        });
        
        mobileRight.addEventListener('mousedown', function(e) {
            e.preventDefault();
            mobileRightPressed = true;
            keys['ArrowRight'] = true;
        });
        
        mobileLaunch.addEventListener('mousedown', function(e) {
            e.preventDefault();
            if (gameState.gameActive) {
                if (gameMode === 'single' && grabber1.state === 'swinging') {
                    grabber1.state = 'extending';
                }
            }
        });
        
        mobileLeft.addEventListener('mouseup', function(e) {
            e.preventDefault();
            mobileLeftPressed = false;
            keys['ArrowLeft'] = false;
        });
        
        mobileRight.addEventListener('mouseup', function(e) {
            e.preventDefault();
            mobileRightPressed = false;
            keys['ArrowRight'] = false;
        });
        
        // Prevent context menu on mobile
        document.addEventListener('contextmenu', function(e) {
            if (e.target.classList.contains('mobileBtn')) {
                e.preventDefault();
            }
        });
        
        // Handle canvas responsiveness
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const canvas = document.getElementById('gameCanvas');
            
            // Get the actual display size
            const rect = canvas.getBoundingClientRect();
            
            // Scale calculations for mouse/touch input (if needed for future features)
            window.canvasScaleX = canvas.width / rect.width;
            window.canvasScaleY = canvas.height / rect.height;
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        resizeCanvas();
        
        // Detect if mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (window.innerWidth <= 768);
        }
        
        // Show mobile controls on mobile devices
        if (isMobileDevice()) {
            document.getElementById('mobileControls').style.display = 'flex';
        }
        
        // Draw initial screen
        drawGame();
    </script>
</body>
</html>